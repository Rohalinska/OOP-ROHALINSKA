# Самостійна робота №16
## Схема розподілу відповідальностей модуля (SRP)

### Мета роботи
Навчитися правильно розділяти код на класи так, щоб **кожен клас виконував лише одну задачу**.
Це допомагає зробити програму простішою, зрозумілішою та легшою для змін.

## Опис проєкту
У цій роботі створено консольний застосунок на C#, який демонструє:
- приклад «поганого» класу, що порушує принцип SRP;
- правильний варіант після рефакторингу;
- розподіл відповідальностей між окремими класами.

Приклад базується на обробці замовлення.

## Поганий приклад (порушення SRP)
Клас `OrderProcessor` виконує одразу кілька дій:
- перевіряє замовлення;
- зберігає його в базу даних;
- відправляє email-повідомлення.

Це порушує принцип SRP, тому що в одного класу забагато відповідальностей.

## Рефакторинг (дотримання SRP)
Після рефакторингу логіка була розділена на окремі класи:

- `IOrderValidator` — відповідає за перевірку замовлення;
- `IOrderRepository` — відповідає за збереження в базу даних;
- `IEmailService` — відповідає за відправку email;
- `OrderService` — координує роботу інших класів.

Кожен клас тепер має **одну чітку відповідальність**.

## Використані принципи
- **SRP (Single Responsibility Principle)** — кожен клас відповідає лише за одну задачу;
- **DIP (Dependency Inversion Principle)** — `OrderService` залежить від інтерфейсів, а не від конкретних класів.

## UML-діаграма
Для візуалізації структури проєкту була створена UML-діаграма класів.
Вона показує всі інтерфейси, класи та зв’язки між ними.

## Демонстрація роботи
У методі `Main` створюються всі необхідні об’єкти, після чого викликається метод
обробки замовлення. Результат роботи виводиться в консоль.

## Використані технології
- Мова програмування: C#
- Тип проєкту: консольний застосунок
- Платформа: .NET

## Висновок
У ході виконання роботи було показано, як принцип SRP допомагає зробити код
більш зрозумілим і структурованим. Розділення логіки на окремі класи
полегшує підтримку та розширення програми.

## Скрін

![alt text](image.png)
